# https://ryute.tistory.com/33
여기보고 로드맵 따라가자


# 1 (by s_problem 1764)
set의 경우 list보다 연산이 빠르다
ex) &(교집합) 연산
따라서 중복된 것들을 구할 때 시간이 초과된다면 set을 이용

# 2 (by problem-1753)
다익스트라 알고리즘 구현할 때 heapq 이용해서 하면 시간 절약

# 3 (by problem-1504)
다익스트라 알고리즘에서 특정한 두 노드를 무조건 지나는 방법은
시작부터 d1까지, d1부터 d2까지, d2부터 마지막 노드까지 다익스트라 세번 돌리고
시작부터 d2까지, d2부터 d1까지, d1뷰토 마지막 노드까지 세번 돌려서
최소값을 반환하면 된다.

# 4 (by problem-1167)
트리의 지름은 임의의 노드에서부터 dfs를 통해 가장 멀리 있는 노드를 찾고,
그 노드에서 dfs를 한번 더 돌려서 나오는 거리중 최장거리를 뜻한다.


# 5 (by problem-1987)
백트래킹 문제에서는 visited 리스트를 그대로 이용하면 안된다.
visited리스트를 무조건 방문했다고 체크해버리면 다시 되돌아갈 수 가 없게된다.
그렇게 하는 대신에 전역변수 하나를 설정하고 count를 인자로 받아서 매번 dfs가 실행될 때마다 answer에 필요한 값(max(answer,count)값 등등)을 저장하고 dfs안에서 dfs가 실행되기전에+1 되고나서 -1 을 해주며 원하는 값을 찾는다.

# 6 (by problem-1987)
리스트에 있는 값을 꺼내서 비교할 때에는 시간을 최소한으로 줄이기 위해서
미리 배열을 선언해놓고 해당 좌표에 있는 배열값을 바로 참조하면 시간을 더 단축시킬 수 있다.

# 7 (by problem-2110)
이진탐색에서 반드시 노드를 start end mid로 잡아야하는 것은 아니다.
이 문제와 같이 거리 등 문제에서 요구하는 조건을 기준으로 잡으면된다.

# 8 (by problem-1920)
bisect를 사용할 때, 해당하는 값이 배열안에 없으면 그 값이 오름차순으로 들어갈만한 인덱스를 반환한다.

# 9
파이썬에서 index로 접근하는것보다 in으로 접근하는 것이 더 빠름
for i in range(n):
    for j in range(m):
            a[i][j]~

for i in a:
    for j in i:
        j~

위 보다 아래가 더 빠름